#include <stdio.h>
#include <string>

#include <atomic>
#include <memory>
#include <vector>

#include "lib/base.h"
#include "lib/ghost.h"

// A series of simple tests for ghOSt schedulers.

namespace ghost {
namespace {

struct ScopedTime {
  ScopedTime() { start = absl::Now(); }
  ~ScopedTime() {
    printf(" took %0.2f ms\n", absl::ToDoubleMilliseconds(absl::Now() - start));
  }
  absl::Time start;
};


int unoptimizableFunc(int numIters) {
  volatile int result = 0; // Using volatile to prevent optimization

  for (int i = 0; i < numIters; i+=17) {
      result += i * (i + std::rand() % 1000); // Performing some computation
  }

  return result;
}

double TaskDistribution(
  int task_count,
  std::vector<std::string>& taskDistributionList
  ) {
  std::vector<std::unique_ptr<ghost::GhostThread>> threads;
  threads.reserve(task_count);

  const int smallTaskNumIters = 2000000; // 2.3 ms
  const int largeTaskNumIters = smallTaskNumIters*100; // 230 ms

  if (task_count < 100 || task_count > 1000 || task_count % 100 != 0) {
        std::cout << "Invalid number of tasks. Should be a multiple of 100 between 100 and 1000." << std::endl;
        return -1;
    }

  int index = (task_count / 100) - 1;
  if (index < 0 || index >= taskDistributionList.size()) {
      std::cout << "Index out of range." << std::endl;
      return -1;
  }

  const std::string& currentString = taskDistributionList[index];
  std::vector<absl::Time> creationTime(task_count);
  std::vector<absl::Time> finishTime(task_count);
  std::vector<int> taskResult(task_count); // Just to prevent compiler optimizations

  int taskIdx = 0;

  for (char c : currentString) {
    int curTaskIdx = taskIdx; // to prevent same copy being shared across threads
    auto curTaskCreationTime = absl::Now();
    creationTime[curTaskIdx] = curTaskCreationTime;
    if (c == '1') {
        threads.emplace_back(new ghost::GhostThread(
            ghost::GhostThread::KernelScheduler::kGhost,
            [&, curTaskIdx]() {
                int result = unoptimizableFunc(smallTaskNumIters);
                taskResult[curTaskIdx] = result;
                finishTime[curTaskIdx] = absl::Now();
            }
        ));
    } else if (c == '0') {
        threads.emplace_back(new ghost::GhostThread(
            ghost::GhostThread::KernelScheduler::kGhost,
            [&, curTaskIdx]() {
                int result = unoptimizableFunc(largeTaskNumIters);
                taskResult[curTaskIdx] = result;
                finishTime[curTaskIdx] = absl::Now();
            }
        ));
    }
    taskIdx+=1;
}

  for (auto& t : threads) t->Join();

  double totalServiceTime = 0;

  for(int i=0; i<task_count; i++) {
    printf("Task: %d\n", i);
    printf("  creationTime: %0.2f ms\n", absl::ToDoubleMilliseconds(creationTime[i] - absl::UnixEpoch()));
    printf("  finishTime: %0.2f ms\n", absl::ToDoubleMilliseconds(finishTime[i] - absl::UnixEpoch()));
    printf("  serviceTime: %0.2f ms\n", absl::ToDoubleMilliseconds(finishTime[i] - creationTime[i]));
    if (currentString[i] == '1')
      printf("  approxBurstTime: 2 ms\n");
    else
      printf("  approxBurstTime: 200 ms\n");
    totalServiceTime += absl::ToDoubleMilliseconds(finishTime[i] - creationTime[i]);
  }

  return totalServiceTime;
}

}  // namespace
}  // namespace ghost

int main() {
  // {
  //   printf("HeavyFirst\n");
  //   ghost::ScopedTime time;
  //   ghost::TaskDistribution(10, 1000, 1000, 10);
  // }
  // {
  //   printf("Uniform\n");
  //   ghost::ScopedTime time;
  //   ghost::TaskDistribution(1000, 10, 1000, 10);
  // }
  std::vector<std::string> taskDistributionList;
  taskDistributionList.push_back("1111110111111101011010111111111100001001001111011111111110000011111111111100111111111001101111011111");
  taskDistributionList.push_back("11101101111111111111111111111111111111111111110111111001000101010001101011011111001011011011011100011111111110110101000011111010011111001110111100111111110111010011111111110111111011001111111100111111");
  taskDistributionList.push_back("110111001101101000001111111110111111100001101111111111111111110111111001001111001110001111110011111111111001110011101111000011110011011011001100010010111011101111111111111111110110110111111101101011111111101101101111011100111111101101111001101111111110111110010111111111111110110111111101111111111111");
  taskDistributionList.push_back("1111001111101011100111110011111111111101001111111101111111111110111111110111111111101111110010111110101111100111010111111111111101011000111111110110110101101110001111111000101111111111010111011111111111011101011010000010101110100111101111101101010111010100110111001111111110110110011111101111101111101111111110111101010111111111101111111101101110011011111101001111010011101101111110011111111000111111");
  taskDistributionList.push_back("11111101100111011010011110110100111011101111110101101101101100110111110111111111101110111101110111111111101101111111111011111101111111011111101110111110101111000111100110011111101101110011011000011011110111111111110111111101111110111100111101011111110100111101111110110111111111111111111111111111101111110000110101111111000111011111101101110101111111110011111110001110110101001011101011101111110111111111100001101101111111110100010110111101001001111100111010101111100001011101111111111111111111110111");
  taskDistributionList.push_back("111001111101111110111111111110011011111111101111110110110111011001111101011101101111101111111110111011110111111111111111111101111111110011011010111111110110111001001111111101110111111110111010101011101111111001101111011000001101111100100000010111111111111111110111110111110111111110101110010111111011111111111110111110111101111101111100110101101110111111111100110111101110111111111010101111110011000101111111011110111011110111110111111011000011111111111110011111011010111010110010100111110111111010011100110111000011011111111101111001111111011111111001101011111101111011001000110111001101110111111001");
  taskDistributionList.push_back("1100010011111001111110110110111100101111111100111011011111111111011111111110101011111101000111111011111011111011111110001011111111110111100111111110111111110100111011100111111111101111101110111111101111101100000110111000111100111011101101010111111111110101110010111110101011101111110110111101110001011011101101101100110011111011111111111111111110101111101011100111011101101111111101111111110101000100011111100000110011111110111110011110011111100101101111110111111111111111111111111111111101101101111101111110110001111111111111101101010111011111110111110111111100110011110111111101011101110011110101010101111011111101111110111111001110011100011111111010111111111111101110111100110111111001110011110111");
  taskDistributionList.push_back("11011101111111111110111011011111111011111010011101111011111111110011101100111101101110111101110111001111011011111110111111011111110011110011111111101011110110111011111101110011000111010100011001110011111101111010111111111010111111001110111011011111111110011111111011101111011111100111010101110011111011111100101111101111111110111110111101110011110111101111011111101010011110011111110011111111011101111101111111011111110101011111111110110110110101111011101011010101110011101111000101111101111111110111010111011011001101111111000111111110111111011101111101111011110111110111110111101110001010011111111011111111000010111101101011111111110101010111101011100111111111011001011101101111110110111101011100101011110111011111110111111110110111111011010110101110011101111010111100111111011000111111111101111101");
  taskDistributionList.push_back("010110110101110110111010111111111101111101111111111110011001111111111110111010110111011111111101111111101000111011111111111110101101111011011110101111111010101111111011111111100111111010110101111111011011111111110111111010011101000011110111000101101110100011111001111111111000011011100101111110110111001011111111110111101101111001110011111110111111111111110001101110100101111110111111011111111111111111011111111111111111101110111111110111011001011111010111101111111001110011111001011011110110011101101111111101111111111111101111111101001010110010001000011111111100111011110101111110100110110111101011010111110111111010111110011111111111011011101001111111110111101010111111111101101101011111001111011011001110111011010110111101111011101111101101111111111011101011111111101110111111110111100101011011101010101011110111111111101111111101101110010111111011010101100110011111010111101110101111100111001111");
  taskDistributionList.push_back("0111101110101000111111101111011111111101000011110111111111111111110111011111111110111110101001100101111111110100111101011111111000101111111100011111111111110111111001101011111111110111111101111111111111111010111111110110111011011111111110110011011111001111011111011110010011110111111111110111001110101011011001000011101111110110011101101101101111111010110111110011110101111111000101100111111111100111100111111110111110111111111111010001111011111111111011111110101111010101111101010111011111111111011110011110111111001100101011111111010011011100111111001110010011010010011111111111111111110111010110100111110111101011111110111111111101111110000100110110010010111011110111111011111111110111001110111101111110010111111110111001010111011110111111100111111111111100111110111101101111111111110111100101111101001111101101111111111111001111111111001111111111011110010101111111111001111100011111110011110110010111101011111101100101011101110111110010010101100111101001111110111111110110011111111111011011001111");
  printf("DynamicVariedWorkload\n");
  auto totalServiceTime = ghost::TaskDistribution(1000, taskDistributionList);
  printf("TotalServiceTime: %0.2f ms\n", totalServiceTime);
}
